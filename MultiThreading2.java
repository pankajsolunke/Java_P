package Corejava;

class MyThread extends Thread{
	public void run() {
		for(int i=1;i<=5;i++) {
			System.out.println("I am lazy thread");
		}
		System.out.println("I'm entered into sleeping stage");
		try {
				Thread.sleep(1000);
		}catch(InterruptedException e) {
			System.out.println("i got interrupted");
		}
	}
}
public class MultiThreading2 {

	public static void main(String[] args){
		MyThread m = new MyThread();
		m.start();
//		m.join();
		m.interrupt();		//---> 1
		System.out.println("end of main Thread");
	}
}

/*
	Getting and Setting name of a Thread:
	* Every Thread in java has some name it may be provided explicitly by the programmer or automatically generated by JVM.
	* Thread class defines the following methods to get and set name of a Thread.
	* Every thread in java has a default name like Thread-0, Thread-1,etc., assigned by the JVM.
	
	Methods:
	1) public final String getName()
	2) public final void setName(String name)
	
	Example:
	class MyThread extends Thread
	{}
	class ThreadDemo{
		public static void main(String[] args){
			System.out.println(Thread.currentThread().getName());//=> main
			MyThread t = new MyThread();
			MyThread t1 = new MyThread();
			System.out.println(t.getName());//=> Thread-0
			Thread.currentThread().setName("worker-1");//=> setName current executing Thread main to worker-1
			System.out.println(Thread.currentThread().getName());//=> worker-1
			System.out.println(t1.getName());
			t1.setName("worker-2");//=> setName MyThread Thread-1 to worker-2
			System.out.println(t1.getName());//=> worker-2
  		}
  	}
  	
  	NOTE: We can get current executing Thread object reference by using Thread.currentThread() method.
  
  	Thread Priorities:
  	* Every Thread in java has some priority it may be default priority generated by JVM (or) Explicitly provided by the programmer.
  	* The valid range of Thread priorities is 1 to 10 [but not 0 to 10] where 1 is the least priority and 10 is highest priority.
  	* Thread class defines the following constants to represent some standard priorities.
  	 	1. Thread. MIN_PRIORITY------- 1
  	 	2. Thread. MAX_PRIORITY------- 10
  	 	3. Thread. NORM_PRIORITY------ 5
  	* There are no constants like Thread.LOW_PRIORITY, Thread.HIGH_PRIORITY
  	* Thread Scheduler uses these priorities while allocating CPU.
  	* The Thread which is having highest priority will get chance for 1st execution.
  	* If 2 Threads having the same priority then we can't expect exact execution order it depends on Thread Scheduler whose behavior is vendor dependent.
  	* We can get and set the priority of a Thread by using the following methods.
  	 	1. public final int getPriority()
  	 	2. public final void setPriority(int newPriority) //=> the allowed values are 1 to 10
  	* The allowed values are 1 to 10 otherwise we will get runtime exception saying "IllegalArgumentException".
  
  	Default Priority:
  		The default priority only for the main Thread is 5.
  		But for all the remaining Threads the default priority will be inheriting from parent to child.
  		That is Whatever the priority parent has by default the same priority will be for the child also.
	
	Example 1:
		class MyThread extends Thread
		{}
		class ThreadPriorityDemo{
			public static void main(String[] args){
				
				System.out.println(Thread.currentThread().getPriority());//=> 5
				Thread.currentThread().setPriority(9);
				MyThread m = new MyThread();
				System.out.println(m.getPriority());//=> 9
				System.out.println(Thread.currentThread().getPriority());//=> 9
				
				------------------------BUT----------------------------
				
		  ⚡===>I can change the order of creating a object the output will be change
				I will be create a object in first the default Priority will be again and can not change
				 
				MyThread m = new MyThread();
				System.out.println(Thread.currentThread().getPriority());//=> 5
				Thread.currentThread().setPriority(9);
				System.out.println(m.getPriority());//=> 5
				System.out.println(Thread.currentThread().getPriority());//=> 9
				
			}
		}
	⚡ Key Point:
		Thread priority is inherited only at the time of creation.
		Later changes to parent’s priority do not affect already created child threads.

	Example 2:
		class MyThread extends Thread{
			public void run(){
				for(int i=0;i<5;i++)
					System.out.println("Child class method");
			}
		}
		
		class ThreadPriorityDemo{
			public static void main(String[] args){
				MyThread m = new MyThread();
			  //m.setPriority(10);				//-----> 1
				m.start();
				for(int i=0;i<5;i++)
					System.out.println("Main class method");
					
			}
		}
	
	NOTE: 
		* If we are commenting line 1 then both main and child Threads will have the same priority and hence we can't expect exact execution order.
		* If we are not commenting line 1 then child Thread has the priority 10 and main Thread has the priority 5 hence child Thread will get chance 
		   for execution and after completing child Thread main Thread will get the chance in this the output is: 


	The Methods to Prevent a Thread from Execution:
	* We can Prevent(stop) a Thread execution by using the following methods.
		1. yield();
		2. join();
		3. sleep();
		
	1. yield():
		1. yield() method causes "to pause current execution Thread for giving the chance of remaining waiting Threads of same priority".
		2. If all waiting Threads have the low priority or if there is no waiting Threads then the same Thread will be continued its execution.
		3. If several waiting Threads with same priority available then we can't expect exact which Thread will get chance for execution.
		4. The Thread which is yielded when it get chance once again for execution is depends on mercy of the Thread scheduler.
		5. public static native void yield();
	Diagram:
							Thread.yield();
					from running to Ready / Runnable
								State
							/-------------\
	----------	 ----------------		-----------			--------
	|New/Born|-->|Ready/Runnable|------>| Running |-------->| Dead | 
	----------	 ----------------		-----------			--------
	
	Example:
		class MyThread extends Thread
		{
			public void run()
			{
				for(int i=0;i<5;i++)
				{
					Thread.yield();
					System.out.println("child thread");
				}
			}
		}
		class ThreadYieldDemo
		{
			public static void main(String[] args)
			{
				MyThread t=new MyThread();
				t.start();
				for(int i=0;i<5;i++)
				{
					System.out.println("main thread");
				}
			}
		}
	Output:
	main thread
	main thread
	main thread
	main thread
	main thread
	child thread
	child thread
	child thread
	child thread
	child thread

		In the above program child Thread always calling yield() method and hence main Thread will get the chance more number of times for execution.
		Hence the chance of completing the main Thread first is high.
		
	NOTE:
	 	 Some operating systems may not provide proper support for yield() method.

	2. join():
		If a Thread wants to wait until completing some other Thread then we should go for join() method.
		
		Example: If a Thread t1 executes t2.join() then t1 should go for waiting state until completing t2.
		
	Diagram:
	--------------			-----------				--------------		
	|Venue Fixing|			| Wedding |				|  wedding   |
	--------------			|  cards  |				|  cards     |
		   |				|printing |				|Distribution|
		   |				-----------				--------------
		   |					 |						   |
		   |t1   			_____|t1___				  _____|_____
		   |    	  		|t1.join()|				  |t2.join()|
		   |	     		/----|-----				 /-----|-----
		   | ______________/  	 | _________________/	   |
		   |/    				 |/						   |
			
	1.public final void join() throws InterrptedException
	2.public final void join(long ms) throws InterruptedException
	3.public final void join(long ms,int ns) throws InterruptedException
	
	Diagram:						---------------
				   |----------------|waiting state|
				   |				-------^-------
				   |  						\
				   |						 \  1)t2.join();
				   |1)If t2 completes(or)	  \ 2)t2.join(1000);
				   |2)If time expires (or)     \3)t2.join(1000,100);
				   |3)If waiting got interrupted\
				   ▼							 \
	----------	  ----------------	  	  ---------	   		 ------
	|new/born|--->|Ready/Runnable|------->|Running|--------->|dead|
	----------	  ----------------	  	  ---------	   		 ------

	Every join() method throws InterruptedException, which is checked exception hence compulsory we should handle either by try catch or by throws keyword.
	Otherwise we will get Compile-Time error.
	
	Example:
		class MyThread extends Thread{
			public void run(){
				for(int i=1;i<=5;i++){
					System.out.println("child class method");
					try{
						Thread.sleep(2000); 2000--> milliseconds
					}
					catch(InterruptedException e){}
				}
			}
		}
		class ThreadJoinDemo{
			public static void main(String[] args) throws InterruptedException{
				MyThread m = new MyThread();
				m.start();
			  //m.join();			//----> 1
				for(int i=1;i<=5;i++)
					System.out.println("main class method");
			}
		}
	
	* If we are commenting line 1 then both Threads will be executed simultaneously and we can't expect exact execution order.
	* If we are not commenting line 1 then main Thread will wait until completing child Thread in this the output is 
	  child class method Thread in 5 times followed by main class method Thread 5 times.

	Waiting of child Thread until completing main Thread:
	Example:
		class MyThread extends Thread
		{
 			static Thread mt;
			public void run()
			{
        		try
        		{
					mt.join(); 
				}
				catch (InterruptedException e){}
				for(int i=0;i<5;i++)
				{
					System.out.println("Child Thread");
				}
			}
		}
		class ThreadJoinDemo
		{
			public static void main(String[] args)throws InterruptedException
			{
				MyThread mt=Thread.currentThread();
				MyThread.t=new MyThread();
				t.start();
				for(int i=0;i<5;i++)
				{
					Thread.sleep(2000);
					System.out.println("Main Thread");
				}
			}
		}

	NOTE:
		 If main Thread calls join() on child Thread object and child Thread called join()
		 on main Thread object then both Threads will wait for each other forever and 
		 the program will be hanged (like deadlock if a Thread class join()
		 method on the same thread itself then the program will be hanged).
	
	Diagram:
	 ┌───────────────┐
 	 │   Main Thread │
 	 └───────┬───────┘
         	 │
         	 │ calls join() on itself
         	 ▼
  	  Wait for Main Thread to finish
         	 │
         	 └──> But Main Thread is itself!
                  Deadlock (infinite wait)
                  
	Example :
		class ThreadDemo {
			public static void main() throws InterruptedException {
			Thread.currentThread().join();
      			 ---------------   -------- 
        		   main              main
			}
		}
		
	2. sleep() method:
		If a Thread don't want to perform any operation for a particular amount of time then we should go for sleep() method.
		
		1. public static native void sleep(long ms) throws InterruptedException
		2. public static void sleep(long ms,int ns) throws InterruptedException
		
	Diagram:
									---------------
				   |----------------|waiting state|
				   |				-------^-------
				   |  						\
				   |						 \  
				   |1)If time expires		  \ 1)Thread.sleep(1000);
				   |2)If sleeping Thread       \2)Thread.sleep(1000,100);
				   |	got interrupted 		\
				   ▼							 \
	----------	  ----------------	  	  ---------	   		 ------
	|new/born|--->|Ready/Runnable|------->|Running|--------->|dead|
	----------	  ----------------	  	  ---------	   		 ------
	
	Example:
		class ThreadSleepDemo {
			public static void main(String[] args) throws InterruptedException {
				System.out.println("P");
				Thread.sleep(1000);
				System.out.println("A");
				Thread.sleep(1000);
				System.out.println("N");
				Thread.sleep(1000);
				System.out.println("K");
				Thread.sleep(1000);
				System.out.println("A");
				Thread.sleep(1000);
				System.out.println("J");
			}
		}

	3. Interrupting a Thread:
		How a Thread can interrupt another Thread ?
	--->If a Thread can interrupt a sleeping or waiting Thread by using interrupt() (break off) method of Thread class.
		
		1. public void interrupt();
		
	Example:
		class MyThread extends Thread
		{
			public void run()
			{
				try
				{
					for(int i=0;i<5;i++)
					{
						System.out.println("I am lazy Thread: "+i);
						Thread.sleep(2000);
					}
				}
				catch (InterruptedException e)
				{
					System.out.println("I got interrupted");
				}
			}
		}
		
		class ThreadInterruptDemo
		{
			public static void main(String[] args)
			{
				MyThread t=new MyThread();
				t.start();
			  //t.interrupt();		//--->1
				System.out.println("End of main Thread");
			}
		}
		
	 * If we are commenting line 1 then main Thread won't interrupt child Thread and hence child Thread will be continued until its completion.
	 * If we are not commenting line 1 then main Thread interrupts child Thread and hence child Thread won't continued until its completion in this case the output is:
		
	Output:
		End of main Thread
		I am lazy Thread: 1
		I got interrupted
		
	NOTE:
		* Whenever we are calling interrupt() method we may not see the effect immediately, 
		  if the target Thread is in sleeping or waiting state it will be interrupted immediately.
		* If the target Thread is not in sleeping or waiting state then interrupt call will wait until target Thread will enter into sleeping or waiting state.
		  Once target Thread entered into sleeping or waiting state it will effect immediately.
		* In its lifetime if the target Thread never entered into sleeping or waiting state then there is no impact of interrupt call simply interrupt call will be wasted.
		
	Example:
		class MyThread extends Thread
		{
			public void run()
			{
				for(int i=0;i<5;i++)
				{
					System.out.println("iam lazy thread");
				}
                System.out.println("I'm entered into sleeping stage");
				try
				{
					Thread.sleep(3000);
				}
				catch (InterruptedException e)
				{
					System.out.println("i got interrupted");
				}
			}
		}
		class ThreadInterruptDemo1
		{
			public static void main(String[] args)
			{
				MyThread t=new MyThread();
				t.start();
				t.interrupt();
				System.out.println("end of main thread");
			}
		}
		
		* In the above program interrupt() method call invoked by main Thread will until child Thread entered into sleeping state.
		* Once child Thread entered into sleeping state then it will be interrupted immediately. 
		
		
		Compression of yield(), join() and sleep() method?
		-------------------------------------------------------------------------------------------
		|		Property		|		Yield()		 |		Join()		|		Sleep()			  |
		-------------------------------------------------------------------------------------------
		|						|To pause current    |If a Thread wants |If a Thread don't want to|
		|						|executing Thread for|wait until complet|perform any operation for|
		|1) Purpose?			|giving the chance of|ing some other	|a particular amount of	  |
		|						|remaining waiting	 |Thread then we	|time then we should go	  |
		|						|Threads of same	 |should go for 	|for sleep() method.	  |
		|						|priority.			 |join.				|						  |
		|-----------------------|--------------------|------------------|-------------------------|
		|2) Is it static ?		|		 Yes		 |		  No		|			Yes			  |
		|-----------------------|--------------------|------------------|-------------------------|
		|3) Is it final ?		|		 No			 |		  Yes		|			No			  |
		|-----------------------|--------------------|------------------|-------------------------|
		|4) Is it overloaded ?	|		 No			 |		  Yes		|			Yes			  |
		|-----------------------|--------------------|------------------|-------------------------|
		|5) Is it throws		|		 No			 |		  Yes		|			Yes			  |
		|  InterruptedException?|					 |					|						  |
		|-----------------------|--------------------|------------------|-------------------------|
		|6) Is it native method?|		 Yes		 |		  No		|sleep(long ms)-->native  |
		|						|					 |					|sleep(long ms,int ns)	  |
		|						|					 |					|	^---> non-native	  |
		-------------------------------------------------------------------------------------------
		
		
		
		
*/